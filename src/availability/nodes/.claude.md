# Formula AST Nodes

This directory contains the Abstract Syntax Tree (AST) node classes that represent parsed prerequisite expressions. Each node type handles a specific aspect of prerequisite logic and formula generation.

## Directory Organization

Nodes are organized by functional purpose into subdirectories:

### `base/` - Foundation Classes
- **Node.ts** - Abstract base class for all AST nodes
  - Error tracking and validation
  - Circular dependency detection
  - Child node management
  - Tree traversal methods

- **FormulaNode.ts** - Abstract base for nodes that generate formulas
  - Extends Node with formula generation capabilities
  - Defines abstract methods: `toPRUsedFormula()`, `toRawMissedFormula()`, `toMissedFormula()`, `toUnknownFormula()`

### `shared/` - Shared Types and Utilities
- **types.ts** - Common type definitions (virtualValueInfo, BlocksArgs, etc.)
- **interfaces.ts** - NumberNode interface
- **enums.ts** - ValueNodeTypes enum (WITH, WITHOUT, VALUE)
- **registries.ts** - Global registries (virtualItems, usesInfo)

### `value/` - Item Lookup and Value Resolution
- **ValueNode.ts** - Resolves item references to row numbers
  - Supports filtering: "Items WITH Tag", "Items WITHOUT Tag"
  - Handles column-specific lookups: "Column=Value"

- **FormulaValueNode.ts** - Abstract base for value-based formulas
  - Links to ValueNode for item resolution
  - Manages available/needed child nodes

- **BooleanFormulaValueNode.ts** - Boolean value formulas (item checked/unchecked)
- **NumberFormulaValueNode.ts** - Numeric value formulas (count of items)
- **SameFormulaNode.ts** - Copies formula logic from another item

### `boolean/` - Boolean Logic
- **BooleanFormulaNode.ts** - Boolean operators (AND, OR, NOT)
  - Recursively handles nested boolean expressions
  - Delegates to comparison or value nodes

- **ComparisonFormulaNode.ts** - Comparison operators (==, !=, >, >=)
  - Compares numeric values
  - Handles X_ITEMS syntax for counting

### `number/` - Arithmetic Operations
- **NumberFormulaNode.ts** - Arithmetic operators (+, -, *, /)
  - Implements NumberNode interface
  - Provides min/max value calculation
  - Generates formulas filtered by status

### `special/` - Special Item Behaviors
- **OptionFormulaNode.ts** - Mutually exclusive choices (OPTION)
  - Creates virtual choice items
  - Ensures only one option per choice is checked

- **UsesFormulaNode.ts** - Consumable items (USES)
  - Tracks total consumption across all items
  - Prevents over-consumption of limited resources

### `constraint/` - Prerequisite Constraints
- **MissedFormulaNode.ts** - Mutual exclusivity (MISSED)
  - Marks items as unavailable when conflicting path chosen

- **OptionalFormulaNode.ts** - Optional prerequisites (OPTIONAL)
  - Items that aren't required for completion tracking

### `root/` - Formula Tree Roots
- **RootNode.ts** - Root of a formula tree for a checklist row
  - Generates complete status formulas
  - Combines all formula types (ERROR, CHECKED, MISSED, etc.)

- **LinkedFormulaNode.ts** - OR semantics for linked prerequisites (LINKED)
  - Item available when ANY linked prerequisite is available

- **CheckedRootNode.ts** - Pre-checked items (CHECKED, INITIAL, PERSIST)
  - Items that start checked or persist across resets

### `blocking/` - Temporal Blocking
- **BlocksUntilFormulaNode.ts** - Blocks items until condition met (BLOCKS)
  - Example: "BLOCKS * UNTIL Chapter 3" blocks all items until Chapter 3
  - Generates BlockedUntilFormulaNode for each blocked item during finalize()

- **BlockedUntilFormulaNode.ts** - Item blocked until condition (BLOCKED)
  - Example: "BLOCKED Boss UNTIL Key" makes Boss unavailable until Key

- **GeneratedBlockedUntilNode.ts** - Auto-generated blocking constraints
  - Created by BlocksUntilFormulaNode during finalization

## Node Lifecycle

### Phase 1: BUILDING
- Nodes created from prerequisite text
- Tree structure established
- Children added to parent nodes

### Phase 2: FINALIZING
- `finalize()` called on all nodes
- Virtual items created (OPTION choices)
- Blocking constraints generated (BLOCKS creates BLOCKED nodes)
- Dependencies resolved
- Circular dependencies detected

### Phase 3: FINALIZED
- Formula generation methods called
- Status formulas produced
- Error checking complete

## Formula Generation Methods

Each FormulaNode must implement these methods:

- **`toPreReqsMetFormula()`** - Are all prerequisites met?
- **`toPRUsedFormula()`** - Are prerequisites consumed by other items?
- **`toRawMissedFormula()`** - Is this item missed (before checking children)?
- **`toMissedFormula()`** - Is this item missed (including children)?
- **`toUnknownFormula()`** - Is availability unknown due to circular dependencies?

## Common Patterns

### Creating Nodes
Use static `create()` factory methods:
```typescript
BooleanFormulaNode.create({ text, translator, row });
```

### Getting Node Information
```typescript
node.getAllPossiblePreReqRows(); // All rows this depends on
node.getDirectPreReqRows(); // Direct dependencies only
node.isDirectlyMissable(); // Can this become unavailable?
node.isInCircularDependency(); // Is there a circular reference?
node.hasErrors(); // Are there validation errors?
```

### Tree Traversal
```typescript
node.finalize(); // Recursively finalize tree
node.getErrors(); // Get all errors (recursive)
node.toString(); // Get original text representation
```

## Key Interfaces

### NumberNode
Nodes that can produce numeric values must implement:
- `getMinValue()` - Minimum possible value
- `getMaxValue()` - Maximum possible value
- `toFormulaByStatus(...status)` - Count items with specific status
- `toFormulaByNotStatus(...status)` - Count items without specific status

## Global Registries

### virtualItems
Tracks virtual items created by OPTION nodes. Key structure:
```typescript
{
  [itemName: string]: {
    rowCounts: { [row: number]: number },  // Which rows contribute
    numNeeded?: number,                    // How many needed (e.g., 1 for choices)
    numPossible?: number                   // How many possible
  }
}
```

### usesInfo
Tracks consumable item usage across rows:
```typescript
{
  [itemName: string]: {
    [row: number]: number  // Amount needed by each row
  }
}
```

## Adding New Node Types

1. Create new file in appropriate subdirectory (follow PascalCase naming)
2. Extend FormulaNode<T> or Node
3. Implement required abstract methods
4. Add static `create()` factory method
5. Export from subdirectory's `index.ts`
6. Import in parser where needed

## Circular Dependencies

The node system has three intentional circular dependencies that resolve at runtime:
- BooleanFormulaNode ↔ ComparisonFormulaNode ↔ NumberFormulaNode
- These work because TypeScript compiles to JavaScript where classes are hoisted

**Note**: As of February 2026, circular dependencies between CellFormulaParser and node classes have been eliminated. Nodes now access parsers through the `IStatusFormulaTranslator` interface method `getParserForRow()` instead of directly importing CellFormulaParser.

When adding new dependencies, ensure they can resolve at runtime through:
- Using interfaces instead of concrete classes where possible
- Lazy evaluation of cross-references
- Factory patterns for object creation
