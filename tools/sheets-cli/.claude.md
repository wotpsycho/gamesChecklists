# Sheets CLI - Claude Context

## Overview

Command-line tool for managing Google Sheets checklists programmatically. Used to create, import, and manipulate checklist data for the Games Checklists project.

## Meta Sheet Structure

Each checklist can have an associated **Meta sheet** (named `[ChecklistName] Meta`) that defines valid values, hierarchies, and styling for checklist columns.

### Meta Sheet Column Formats

**Format 1: Column with Shared Styling**
```
ColumnName[OtherColumn1, OtherColumn2]
```
- Defines valid values and styling for `ColumnName`
- Styling (color, background, italics, bold, hyperlinks) also applies to the columns listed in brackets
- Example: `Type[✓,Item,Area,Location]` - styling for Type values applies to checkbox, Item, Area, and Location columns

**Format 2: Parent Hierarchy**
```
PARENT(ColumnName)
```
- Defines a parent-child hierarchy for the named column
- Values in this column are parent categories for values in the primary column

### Valid vs Invalid Values

- **Valid values**: Only values **above the first empty space** in a Meta column are considered valid
- **Invalid values**: Values **below the first empty space** are invalid values found in the checklist that haven't been added to the valid list yet

### Example Meta Sheet Structure

```
Type[✓,Item,Area,Location]    PARENT(Type)    Area[Location]    PARENT(Area)
Story                                          Leide
Chapter Complete               Story           Duscae
Boss                          Story           Cleigne
Quest
Main Quest                    Quest           Hammerhead          Leide
Side Quest                    Quest           Galdin Quay         Leide
                                               Lestallum           Cleigne
(empty line - values below are invalid)        Cape Caem           Cleigne
Old Invalid Type
```

### Common Hierarchical Columns

- **Type**: Story → Chapter Complete, Story → Boss, Quest → Main Quest, Quest → Side Quest
- **Area**: Region → Specific Locations (e.g., Leide → Hammerhead, Cleigne → Lestallum)

### How Styling Works

1. Set formatting (colors, fonts, etc.) on a value cell in the Meta sheet
2. That formatting automatically applies to:
   - All rows with that value in the primary column
   - The same rows in all columns listed in brackets
3. Child values inherit parent formatting unless overridden

### Updating Meta Sheets

When adding new valid values or hierarchies:
1. Add values **above** the first empty space in the Meta column
2. Define parent relationships in the `PARENT(ColumnName)` column
3. Apply desired formatting to the value cells
4. Use the main app's "Sync Meta" action to apply changes to the checklist

## Critical Rules for Checklist Data

### Formula Columns - DO NOT TOUCH

**CRITICAL**: Two columns contain formulas managed by the main Apps Script application and should NEVER be read or written by this tool:

1. **Column A: ✓ (Checkbox)** - Contains formulas for checkbox state
2. **Column H: Available** (or last column) - Contains calculated status formulas

**DO NOT** read or write these columns. They are automatically recalculated by the main application as needed.

**Only work with columns B through G** (Type through Notes).

### Standard Column Structure

**CRITICAL**: Always read/write ONLY columns B through G (Type through Notes). Never touch columns A (Checkbox) or H (Available).

Standard checklist columns:

- **A: ✓ (Checkbox)** - ❌ DO NOT READ/WRITE (formula column, managed by main app)
- **B: Type** - ✅ Item category/type
- **C: Item** - ✅ Item name/description
- **D: Area** - ✅ Geographical area or category
- **E: Location** - ✅ Specific location details (can be empty)
- **F: Pre-Reqs** - ✅ Prerequisites (can be empty or multi-line)
- **G: Notes** - ✅ Additional information (can be empty or multi-line)
- **H: Available** - ❌ DO NOT READ/WRITE (formula column, managed by main app)

**Additional columns may exist** between Item and Pre-Reqs in some checklists, but the standard is shown above.

**Always include all columns B through G** when reading or writing data. Omitting columns (especially Notes) will cause misalignment when inserting/replacing rows.

### Multi-line Values

Pre-Reqs and Notes columns often contain multi-line values. Use `\n` to separate lines:

```javascript
const preReqs = "MM.1: Find Mystery Map\nChapter 2 Complete";
```

### Location Splitting Pattern

When parsing location data with commas, split into Area and Location:

```javascript
function splitLocation(location) {
  const parts = location.split(',').map(s => s.trim());
  return {
    area: parts[0] || '',           // First part = Area
    location: parts.slice(1).join(', ') || ''  // Rest = Location
  };
}
```

## Common Patterns

### Prerequisite Patterns

See `PREREQ_PATTERNS.md` for comprehensive documentation of all prerequisite patterns with real examples from Ni No Kuni checklists.

**Quick reference of major patterns**:

#### LINKED Pattern
- Creates parent-child relationships
- Header item tracks status of multiple sub-tasks
- Syntax: `LINKED [item pattern]`
- Example: `LINKED S.1-*` (matches all items starting with S.1-)

#### USES Pattern
- Tracks consumable resources used across multiple items
- Prevents over-consumption of limited resources
- Syntax: `USES [number]x [item]` or `USES [item] [number]`
- Example: `USES *Enthusiasm 1` (uses 1 Enthusiasm from any source)

#### OPTION Pattern
- Creates mutually exclusive choices
- Only one option from a group can be selected
- Syntax: `OPTION [Choice ID]`
- Example: Three familiars with `OPTION Serenade a Familiar`

#### MISSED Pattern
- Marks items as mutually exclusive
- Checking one makes the other unavailable
- Syntax: `MISSED [item name]`
- Example: `MISSED Spare the Boss`

#### BLOCKS Pattern
- Temporarily blocks items until condition is met
- Useful for story gating
- Syntax: `BLOCKS [pattern] UNTIL [condition]`
- Example: `BLOCKS Area=Dungeon UNTIL Get Key`

#### Other Keywords
- **PERSIST**: Item remains checked through resets
- **CHECKED/INITIAL**: Item starts checked
- **BLOCKED**: Item blocked until condition (usually auto-generated)
- **OPTIONAL**: Optional prerequisites

### Task/Subtask Pattern

See `TASK_SUBTASK_PATTERN.md` for comprehensive documentation.

**Quick reference**:
- Header row with `LINKED [Prefix].[Number]:*` pre-req
- Sub-task rows with format `[Prefix].[Number]: [Description]`
- Sequential chain where each sub-task depends on previous

**Example prefixes**:
- `H.` - Hunts
- `MM.` - Mystery Maps
- `Q.` - Quests
- `A.` - Achievements
- `S.` - Story quests (Ni No Kuni 2)

### Sequential Pre-Req Chains

For linear progressions, make each item depend on the previous:

```javascript
for (let i = 0; i < items.length; i++) {
  const preReq = i === 0 ? '' : items[i - 1].name;
  // ... set preReq for items[i]
}
```

### Chapter Pre-Requisites

When converting chapter availability:
- "Chapter X" → "Chapter X-1 Complete"
- "Anytime" → empty string

```javascript
function chapterToPreReq(chapter) {
  if (chapter === 'Anytime') return '';
  const match = chapter.match(/Chapter (\d+)/);
  if (match) {
    return `Chapter ${parseInt(match[1]) - 1} Complete`;
  }
  return chapter;
}
```

## Data Import Guidelines

### Reading from Sheets

**CRITICAL**: Always read ONLY columns B:G (Type through Notes). Do NOT read columns A (Checkbox) or H (Available).

```javascript
import { readSheet } from './sheets.js';
// Read Type through Notes (B:G only)
const data = await readSheet(spreadsheetId, 'SheetName!B:G');
```

**Why B:G specifically?**
- Column A (Checkbox) and Column H (Available) contain formulas managed by the main application
- Reading these columns is unnecessary and may cause issues
- Columns B-G contain all the data this tool needs to manipulate

### Writing to Sheets

**CRITICAL**: The approach differs between Checklist sheets and Meta sheets:

#### Writing to Checklist Sheets

Write ONLY to columns B:G (Type through Notes). Do NOT write to columns A (Checkbox) or H (Available).

Always use `'RAW'` value input option to preserve formulas and newlines:

```javascript
import { writeSheet } from './sheets.js';
// Write Type through Notes (B:G only), starting at row X
const range = `SheetName!B${startRow}:G${endRow}`;
await writeSheet(spreadsheetId, range, values, 'RAW');
```

**Why write all data columns (B:G)?**
- Writing to column A or H would overwrite formulas managed by the main application
- Must include ALL data columns (B-G) to prevent misalignment when inserting/replacing rows
- The main app will automatically recalculate Checkbox and Available columns after data changes

#### Writing to Meta Sheets

Write ONLY the specific columns you're updating. Do NOT overwrite other columns.

```javascript
import { readSheet, writeSheet } from './sheets.js';

// Read the full sheet first
const allData = await readSheet(spreadsheetId, 'SheetName Meta!A:Z');

// Update only the specific columns (e.g., C and D for Area columns)
// Build rows with ALL columns, but only change the target columns
const updatedData = allData.map((row, i) => {
  if (i === 0) return row; // Keep headers unchanged

  return [
    row[0] || '', // Column A - preserve existing
    row[1] || '', // Column B - preserve existing
    newAreaValue[i], // Column C - UPDATE
    newParentValue[i], // Column D - UPDATE
    row[4] || '', // Column E - preserve existing
    // ... etc for all columns
  ];
});

const range = `SheetName Meta!A1:Z${updatedData.length}`;
await writeSheet(spreadsheetId, range, updatedData, 'RAW');
```

**Why write all columns but only change specific ones?**
- Meta sheets have multiple independent column hierarchies (Type, Area, etc.)
- Each column system should be updated independently without affecting others
- Must preserve all columns to maintain the sheet structure

### Finding Data Ranges

When replacing specific rows, find the start and end indices first:

```javascript
// Read data from B:G (Type through Notes)
const allData = await readSheet(spreadsheetId, 'SheetName!B:G');

let startIndex = -1;
let endIndex = -1;

for (let i = 0; i < allData.length; i++) {
  // Column indices are now 0-based relative to column B
  // Column B (Type) is now index 0
  if (allData[i][0] === 'Target Type') {
    if (startIndex === -1) startIndex = i;
    endIndex = i;
  } else if (startIndex !== -1) {
    break; // Found all consecutive rows
  }
}
```

### Preserving Structure

When importing data, preserve header rows (TITLE, SETTINGS, QUICK_FILTER, HEADERS):

```javascript
// Read from B:G (Type through Notes)
const data = await readSheet(spreadsheetId, 'SheetName!B:G');

// Find the header row (has "Type" in first column)
const headerIndex = data.findIndex(row => row[0] === 'Type');
const dataStartIndex = headerIndex + 1;

// Write starting from data rows (B through G)
const range = `SheetName!B${dataStartIndex + 1}:G${dataStartIndex + newData.length}`;
await writeSheet(spreadsheetId, range, newData, 'RAW');
```

## Temporary Files

Use the `temp/` directory for parsing scripts and intermediate files:

```
tools/sheets-cli/temp/
├── parse-*.py          # Python parsing scripts
├── transform-*.js      # JavaScript transformation scripts
├── *-raw.json          # Raw parsed data
├── *-parsed.json       # Processed parsed data
└── *-output.json       # Final output for import
```

The `temp/` directory is git-ignored and can be used freely for experimentation.

## Python Parsing Scripts

When parsing HTML with BeautifulSoup:

```python
from bs4 import BeautifulSoup
import json

with open('/path/to/file.html', 'r', encoding='utf-8') as f:
    html = f.read()

soup = BeautifulSoup(html, 'html.parser')
# ... parse tables, extract data

# Save to temp directory
with open('temp/output.json', 'w') as f:
    json.dump(data, f, indent=2)
```

## Node.js Transformation Scripts

When transforming parsed data, include ALL columns from Type through Notes:

```javascript
import { readFile, writeFile } from 'fs/promises';

const parsed = JSON.parse(await readFile('temp/parsed.json', 'utf-8'));

// Transform data - Type through Notes (B through G)
// DO NOT include checkbox column (A)
const output = parsed.map(item => [
  item.type,           // Column B: Type
  item.name,           // Column C: Item
  item.area,           // Column D: Area
  item.location || '', // Column E: Location
  item.preReqs || '',  // Column F: Pre-Reqs
  item.notes || ''     // Column G: Notes - ALWAYS INCLUDE!
]);

await writeFile('temp/output.json', JSON.stringify(output, null, 2));
```

## Common Issues and Solutions

### Issue: Notes column misaligned after inserting rows

**Problem**: Inserted 28 rows without Notes data, causing all subsequent Notes to be misaligned.

**Solution**: ALWAYS include the Notes column (and all columns from Type through Notes) when reading/writing data, even if the Notes are empty. Use empty strings `''` for missing values.

### Issue: Checkbox or Available formulas overwritten

**Problem**: Reading/writing columns A or H overwrites formulas with static values.

**Solution**:
- DO NOT read or write column A (Checkbox) or column H (Available)
- Always work ONLY with columns B:G (Type through Notes)
- The main Apps Script application will automatically recalculate formula columns

### Issue: Multi-line pre-reqs not preserved

**Solution**: Use `'RAW'` value input option when writing to sheets, not `'USER_ENTERED'`.

### Issue: Formulas converted to values

**Solution**: Use `'RAW'` value input option to preserve formulas as-is.

### Issue: Location data concatenated incorrectly

**Solution**: Use the location splitting pattern to separate Area and Location columns.

### Issue: Chapter pre-reqs off by one

**Solution**: Remember "Available: Chapter X" means "Pre-Req: Chapter X-1 Complete".

## Tips

1. **Test with small datasets first** - Parse and import 1-2 items to verify format before doing bulk imports
2. **Save intermediate files** - Keep raw parsed data, transformed data, and output separate for debugging
3. **Use descriptive filenames** - Include version numbers (v2, v3) when iterating on parsing scripts
4. **Check the checklist structure** - Use `readSheet` to inspect existing data before importing
5. **Preserve existing data** - When replacing rows, only replace what's necessary, keep the rest intact
6. **Always use B:G range** - Never read/write columns A (Checkbox) or H (Available) - they're formula columns
7. **Include all data columns** - Always include Type, Item, Area, Location, Pre-Reqs, AND Notes to prevent misalignment

## Example Workflows

### Workflow 1: Parse HTML → Transform → Import

```bash
# 1. Parse HTML to JSON
python3 temp/parse-data.py

# 2. Transform to checklist format
node temp/transform-data.js

# 3. Import to sheet
node temp/import-data.js
```

### Workflow 2: Create New Checklist

```bash
# Create a new checklist from template
npm run cli create-checklist "New Game Checklist"
```

### Workflow 3: Bulk Import from JSON

```bash
# Import data from JSON file
npm run cli import --sheet "Game Name" --file data.json --mode append
```

## References

- **Main project docs**: `/Users/Brycen/dev/gamesChecklists/CLAUDE.md`
- **Task/Subtask pattern**: `TASK_SUBTASK_PATTERN.md`
- **Deployment docs**: `/Users/Brycen/dev/gamesChecklists/DEPLOYMENT.md`
- **Google Sheets API**: https://developers.google.com/sheets/api/reference/rest
